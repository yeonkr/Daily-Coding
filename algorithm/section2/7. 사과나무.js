/*
현수의 농장은 N*N 격자판으로 이루어져 있으며, 각 격자안에는 한 그루의 사과나무가 심어저 있다.
N의 크기는 항상 홀수이다.
가을이 되어 사과를 수확해야 하는데 현수는 격자판안의 사 과를 수확할 때 다이아몬드 모양의 격자구역 안에 있는 사과만 수확한다.
현수과 수확하는 사과의 총 개수를 출력하세요.

▣ 입력설명
첫 줄에 자연수 N(홀수)이 주어진다.(3<=N<=20)
두 번째 줄부터 N개의 줄에 걸쳐 각 줄에 N개의 자연수가 주어진다.
이 자연수는 각 격자안에 있는 사과나무에 열린 사과의 개수이다.
각 격자안의 사과의 개수는 100을 넘지 않는다.

▣ 출력설명
수확한 사과의 총 개수를 출력합니다.
ss
▣ 입력예제 1
5
10 13 10 12 15
12 39 30 23 11
11 25 50 53 15
19 27 29 37 27
19 13 30 13 19

▣ 출력예제 1
379
*/

function solution(arr) {
  let answer = 0; // 사과의 총 개수
  const n = arr.length; // 격자판의 크기
  const middle = Math.floor(n / 2); // 중간 인덱스
  let start = middle; // 시작 인덱스
  let end = middle; // 끝 인덱스
  for (let i = 0; i < n; i++) {
    // 행
    for (let j = start; j <= end; j++) {
      // 열
      answer += arr[i][j]; // 사과의 총 개수
    }
    if (i < middle) {
      // 중간 인덱스 전까지는 start--, end++
      start--;
      end++;
    } else {
      // 중간 인덱스 이후부터는 start++, end--
      start++;
      end--;
    }
  }
  return answer; // 사과의 총 개수 반환
}

let arr = [
  [10, 13, 10, 12, 15],
  [12, 39, 30, 23, 11],
  [11, 25, 50, 53, 15],
  [19, 27, 29, 37, 27],
  [19, 13, 30, 13, 19],
];
console.log(solution(arr)); // 379

/*
봉우리

▣ 입력설명
첫 줄에 자연수 N이 주어진다.(1<=N<=50)
두 번째 줄부터 N줄에 걸쳐 각 줄에 N개의 자연수가 주어진다.
각 자연수는 100을 넘지 않는다.

▣ 출력설명
첫 줄에 봉우리의 개수를 출력한다.

▣ 입력예제 1
5
5 3 7 2 3
3 7 1 6 1
7 2 5 3 4
4 3 6 4 1
8 7 3 5 2

▣ 출력예제 1
10
*/

function solution2(arr) {
  let answer = 0; // 봉우리의 개수
  const n = arr.length; // 격자판의 크기
  const dx = [-1, 0, 1, 0]; // 상하좌우 x좌표
  const dy = [0, 1, 0, -1]; // 상하좌우 y좌표

  for (let i = 0; i < n; i++) {
    // 행
    for (let j = 0; j < n; j++) {
      // 열
      let flag = 1; // 봉우리 여부. flag = true
      for (let k = 0; k < 4; k++) {
        // 상하좌우
        let nx = i + dx[k];
        let ny = j + dy[k];
        if (
          // 상하좌우 x좌표가 격자판을 벗어나거나
          nx < 0 ||
          nx >= n ||
          // 상하좌우 y좌표가 격자판을 벗어나거나
          ny < 0 ||
          ny >= n ||
          // 상하좌우 중 봉우리가 아니거나
          arr[nx][ny] >= arr[i][j]
        ) {
          // 상하좌우 인덱스가 유효하고, 상하좌우 인덱스 값이 현재 인덱스 값보다 크거나 같으면 봉우리가 아님
          flag = 0; // flag = false
          break;
        }
      }
      if (flag) answer++;
    }
  }
  return answer;
}

let arr2 = [
  [5, 3, 7, 2, 3],
  [3, 7, 1, 6, 1],
  [7, 2, 5, 3, 4],
  [4, 3, 6, 4, 1],
  [8, 7, 3, 5, 2],
];
console.log(solution2(arr2)); // 10
